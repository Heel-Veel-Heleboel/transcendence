import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';

import type * as JwtModule from 'jsonwebtoken';


vi.mock('jsonwebtoken', () => ({
  default: {
    sign: vi.fn(),
    verify: vi.fn()
  }
}));


vi.mock('../../../src/auth/src/config/jwt.ts', () => ({
  getJwtConfig: vi.fn(() => ({
    privateKey: 'mock-private-key',
    publicKey: 'mock-public-key',
    expirationAccessToken: '15m',
    expirationRefreshToken: '7d',
    algorithm: 'RS256',
    issuer: 'AuthService',
    audience: 'TranscendenceApp'
  }))
}));

describe('JWT Utils', () => {
  let jwt: typeof JwtModule;
  let generateAccessToken: any;
  let verifyAccessToken: any;

  beforeEach(async () => {
    vi.resetModules();
    

    const jwtModule = await import('jsonwebtoken');
    jwt = jwtModule.default;
    

    const jwtUtils = await import('../../../src/auth/src/utils/jwt.ts');
    generateAccessToken = jwtUtils.generateAccessToken;
    verifyAccessToken = jwtUtils.verifyAccessToken;

    vi.mocked(jwt.sign).mockClear();
    vi.mocked(jwt.verify).mockClear();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('generateAccessToken', () => {
    it('should call jwt.sign with correct payload and private key', () => {
      const mockPayload = { user_id: 123, email: 'test@example.com' };
      const mockToken = 'mock.jwt.token';
      
      vi.mocked(jwt.sign).mockReturnValue(mockToken as any);
      
      const result = generateAccessToken(mockPayload);
      
      expect(jwt.sign).toHaveBeenCalledTimes(1);
      expect(jwt.sign).toHaveBeenCalledWith(
        mockPayload,
        'mock-private-key',
        expect.objectContaining({
          algorithms: ['RS256'],
          expiresIn: '15m',
          issuer: expect.any(String),
          audience: expect.any(String)
        })
      );
      expect(result).toBe(mockToken);
    });

    it('should use correct algorithm from config', () => {
      const mockPayload = { user_id: 456 };
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken(mockPayload);
      
      const callArgs = vi.mocked(jwt.sign).mock.calls[0];
      expect(callArgs[2]).toMatchObject({ algorithms: ['RS256'] });
    });

    it('should use correct expiration time from config', () => {
      const mockPayload = { user_id: 789 };
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken(mockPayload);
      
      const callArgs = vi.mocked(jwt.sign).mock.calls[0];
      expect(callArgs[2]).toMatchObject({ expiresIn: '15m' });
    });

    it('should include issuer and audience claims', () => {
      const mockPayload = { user_id: 999 };
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken(mockPayload);
      
      const callArgs = vi.mocked(jwt.sign).mock.calls[0];
      expect(callArgs[2]).toHaveProperty('issuer');
      expect(callArgs[2]).toHaveProperty('audience');
      expect(callArgs[2].issuer).toBeTruthy();
      expect(callArgs[2].audience).toBeTruthy();
    });

    it('should return the token generated by jwt.sign', () => {
      const expectedToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.mock';
      vi.mocked(jwt.sign).mockReturnValue(expectedToken as any);
      
      const result = generateAccessToken({ user_id: 1 });
      
      expect(result).toBe(expectedToken);
    });

    it('should handle empty payload', () => {
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken({} as any);
      
      expect(jwt.sign).toHaveBeenCalledWith(
        {},
        expect.any(String),
        expect.any(Object)
      );
    });

    it('should propagate errors from jwt.sign', () => {
      const error = new Error('Invalid key format');
      vi.mocked(jwt.sign).mockImplementation(() => {
        throw error;
      });
      
      expect(() => generateAccessToken({ user_id: 1 })).toThrow('Invalid key format');
    });
  });

  describe('verifyAccessToken', () => {
    it('should call jwt.verify with correct token and public key', () => {
      const mockToken = 'valid.jwt.token';
      const mockDecoded = { user_id: 123, email: 'test@example.com' };
      
      vi.mocked(jwt.verify).mockReturnValue(mockDecoded as any);
      
      const result = verifyAccessToken(mockToken);
      
      expect(jwt.verify).toHaveBeenCalledTimes(1);
      expect(jwt.verify).toHaveBeenCalledWith(
        mockToken,
        'mock-public-key',
        expect.objectContaining({
          algorithms: ['RS256'],
          issuer: expect.any(String),
          audience: expect.any(String)
        })
      );
      expect(result).toEqual(mockDecoded);
    });


    it('should verify with correct algorithm', () => {
      vi.mocked(jwt.verify).mockReturnValue({ user_id: 1 } as any);
      
      verifyAccessToken('token');
      
      const callArgs = vi.mocked(jwt.verify).mock.calls[0];
      expect(callArgs[2]).toMatchObject({ algorithms: ['RS256'] });
    });

    it('should verify issuer claim', () => {
      vi.mocked(jwt.verify).mockReturnValue({ user_id: 1 } as any);
      
      verifyAccessToken('token');
      
      const callArgs = vi.mocked(jwt.verify).mock.calls[0];
      expect(callArgs[2]).toHaveProperty('issuer');
      expect(callArgs[2]?.issuer).toBeTruthy();
    });

    it('should verify audience claim', () => {
      vi.mocked(jwt.verify).mockReturnValue({ user_id: 1 } as any);
      
      verifyAccessToken('token');
      
      const callArgs = vi.mocked(jwt.verify).mock.calls[0];
      expect(callArgs[2]).toHaveProperty('audience');
      expect(callArgs[2]?.audience).toBeTruthy();
    });

    it('should return decoded payload', () => {
      const expectedDecoded = { 
        user_id: 456, 
        email: 'user@test.com',
        iat: 1234567890,
        exp: 1234568890
      };
      vi.mocked(jwt.verify).mockReturnValue(expectedDecoded as any);
      
      const result = verifyAccessToken('token');
      
      expect(result).toEqual(expectedDecoded);
    });

    it('should throw error for expired token', () => {
      const error = new Error('jwt expired');
      error.name = 'TokenExpiredError';
      vi.mocked(jwt.verify).mockImplementation(() => {
        throw error;
      });
      
      expect(() => verifyAccessToken('expired.token')).toThrow('jwt expired');
    });

    it('should throw error for invalid signature', () => {
      const error = new Error('invalid signature');
      error.name = 'JsonWebTokenError';
      vi.mocked(jwt.verify).mockImplementation(() => {
        throw error;
      });
      
      expect(() => verifyAccessToken('invalid.token')).toThrow('invalid signature');
    });

    it('should throw error for malformed token', () => {
      const error = new Error('jwt malformed');
      error.name = 'JsonWebTokenError';
      vi.mocked(jwt.verify).mockImplementation(() => {
        throw error;
      });
      
      expect(() => verifyAccessToken('malformed')).toThrow('jwt malformed');
    });
  });
});


import { generateRefreshToken, hashRefreshToken, compareRefreshToken } from '../../../src/auth/src/utils/jwt.ts';
import { CryptoErrorMessage } from '../../../src/auth/src/constants/jwt.ts';


describe('Refresh Token Utils', () => {
  describe('generateRefreshToken', () => {
    it('should return an object with id and hashedRefreshToken', () => {
      const result = generateRefreshToken(64);
      expect(result).toHaveProperty('id');
      expect(result).toHaveProperty('hashedRefreshToken');
      expect(typeof result.id).toBe('string');
      expect(typeof result.hashedRefreshToken).toBe('string');
    });

    it('should generate a valid UUID as id', () => {
      const result = generateRefreshToken(64);
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      expect(result.id).toMatch(uuidRegex);
    });

    it('should generate a hashed token (sha256 produces 64 char hex)', () => {
      const result = generateRefreshToken(64);
      expect(result.hashedRefreshToken.length).toBe(64);
    });

    it('should generate unique tokens on multiple calls', () => {
      const result1 = generateRefreshToken(64);
      const result2 = generateRefreshToken(64);
      expect(result1.id).not.toBe(result2.id);
      expect(result1.hashedRefreshToken).not.toBe(result2.hashedRefreshToken);
    });

    it('should generate unique ids for different sizes', () => {
      const sizes = [16, 32, 64, 128];
      const ids = sizes.map(size => generateRefreshToken(size).id);
      const uniqueIds = new Set(ids);
      expect(uniqueIds.size).toBe(sizes.length);
    });

    it('should throw error when size is less than zero or too large', () => {
      expect(() => generateRefreshToken(2147483647)).toThrow(CryptoErrorMessage.SIZE_OUT_OF_RANGE.replace('{size}', '2147483647'));
      expect(() => generateRefreshToken(-10)).toThrow(CryptoErrorMessage.SIZE_OUT_OF_RANGE.replace('{size}', '-10'));
    });
  });

  describe('hashRefreshToken', () => {
    it('should return a hashed version of the refresh token', () => {
      const refreshToken = 'sample-refresh-token';
      const hashed_token = hashRefreshToken(refreshToken, 'sha256');
      expect(typeof hashed_token).toBe('string');
      expect(hashed_token).not.toBe(refreshToken);
      expect(hashed_token.length).toBe(64); 
    });

    it('should throw error when hashing an empty token', () => {
      expect(() => hashRefreshToken('', 'sha256')).toThrow('Refresh token cannot be empty.');
    });
  });

  describe('compareRefreshToken', () => {
    it('should return true for matching refresh token and hash', () => {
      const refreshToken = 'another-sample-token';
      const hashed_token = hashRefreshToken(refreshToken, 'sha256');
      const isMatch = compareRefreshToken(refreshToken, hashed_token, 'sha256');
      expect(isMatch).toBe(true);
    });

    it('should return false for non-matching refresh token and hash', () => {
      const refreshToken =  'sample-token-one';
      const differentToken = 'sample-token-two';
      const hashed_token = hashRefreshToken(refreshToken, 'sha256');
      const isMatch = compareRefreshToken(differentToken, hashed_token, 'sha256');
      expect(isMatch).toBe(false);
    });

    it('should return false when comparing with an empty refresh token', () => {
      const hashed_token = hashRefreshToken('valid-token', 'sha256');
      const isMatch = compareRefreshToken('', hashed_token, 'sha256');
      expect(isMatch).toBe(false);
    });

    it('should return false when comparing with an empty hashed token', () => {
      const isMatch = compareRefreshToken('valid-token', '', 'sha256');
      expect(isMatch).toBe(false);
    });

    it('should throw error when hashing algorithm is missing', () => {
      const refreshToken = 'test-token';
      const hashed_token = hashRefreshToken(refreshToken, 'sha256');
      expect(() => compareRefreshToken(refreshToken, hashed_token, '')).toThrow('Hashing algorithm must be specified.');
    });
  });
});