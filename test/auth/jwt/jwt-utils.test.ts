import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import type * as JwtModule from 'jsonwebtoken';


vi.mock('jsonwebtoken', () => ({
  default: {
    sign: vi.fn(),
    verify: vi.fn()
  }
}));


vi.mock('../../../src/auth/src/config/jwt.ts', () => ({
  createJwtConfig: vi.fn(() => ({
    privateKey: 'mock-private-key',
    publicKey: 'mock-public-key',
    expirationAccessToken: '15m',
    expirationRefreshToken: '7d',
    algorithm: 'RS256'
  }))
}));

describe('JWT Utils', () => {
  let jwt: typeof JwtModule;
  let generateAccessToken: any;
  let verifyAccessToken: any;

  beforeEach(async () => {
    vi.resetModules();
    

    const jwtModule = await import('jsonwebtoken');
    jwt = jwtModule.default;
    

    const jwtUtils = await import('../../../src/auth/src/utils/jwt.ts');
    generateAccessToken = jwtUtils.generateAccessToken;
    verifyAccessToken = jwtUtils.verifyAccessToken;

    vi.mocked(jwt.sign).mockClear();
    vi.mocked(jwt.verify).mockClear();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('generateAccessToken', () => {
    it('should call jwt.sign with correct payload and private key', () => {
      const mockPayload = { userId: 123, email: 'test@example.com' };
      const mockToken = 'mock.jwt.token';
      
      vi.mocked(jwt.sign).mockReturnValue(mockToken as any);
      
      const result = generateAccessToken(mockPayload);
      
      expect(jwt.sign).toHaveBeenCalledTimes(1);
      expect(jwt.sign).toHaveBeenCalledWith(
        mockPayload,
        'mock-private-key',
        expect.objectContaining({
          algorithm: 'RS256',
          expiresIn: '15m',
          issuer: expect.any(String),
          audience: expect.any(String)
        })
      );
      expect(result).toBe(mockToken);
    });

    it('should use correct algorithm from config', () => {
      const mockPayload = { userId: 456 };
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken(mockPayload);
      
      const callArgs = vi.mocked(jwt.sign).mock.calls[0];
      expect(callArgs[2]).toMatchObject({ algorithm: 'RS256' });
    });

    it('should use correct expiration time from config', () => {
      const mockPayload = { userId: 789 };
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken(mockPayload);
      
      const callArgs = vi.mocked(jwt.sign).mock.calls[0];
      expect(callArgs[2]).toMatchObject({ expiresIn: '15m' });
    });

    it('should include issuer and audience claims', () => {
      const mockPayload = { userId: 999 };
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken(mockPayload);
      
      const callArgs = vi.mocked(jwt.sign).mock.calls[0];
      expect(callArgs[2]).toHaveProperty('issuer');
      expect(callArgs[2]).toHaveProperty('audience');
      expect(callArgs[2].issuer).toBeTruthy();
      expect(callArgs[2].audience).toBeTruthy();
    });

    it('should return the token generated by jwt.sign', () => {
      const expectedToken = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.mock';
      vi.mocked(jwt.sign).mockReturnValue(expectedToken as any);
      
      const result = generateAccessToken({ userId: 1 });
      
      expect(result).toBe(expectedToken);
    });

    it('should handle empty payload', () => {
      vi.mocked(jwt.sign).mockReturnValue('token' as any);
      
      generateAccessToken({} as any);
      
      expect(jwt.sign).toHaveBeenCalledWith(
        {},
        expect.any(String),
        expect.any(Object)
      );
    });

    it('should propagate errors from jwt.sign', () => {
      const error = new Error('Invalid key format');
      vi.mocked(jwt.sign).mockImplementation(() => {
        throw error;
      });
      
      expect(() => generateAccessToken({ userId: 1 })).toThrow('Invalid key format');
    });
  });

  describe('verifyAccessToken', () => {
    it('should call jwt.verify with correct token and public key', () => {
      const mockToken = 'valid.jwt.token';
      const mockDecoded = { userId: 123, email: 'test@example.com' };
      
      vi.mocked(jwt.verify).mockReturnValue(mockDecoded as any);
      
      const result = verifyAccessToken(mockToken);
      
      expect(jwt.verify).toHaveBeenCalledTimes(1);
      expect(jwt.verify).toHaveBeenCalledWith(
        mockToken,
        'mock-public-key',
        expect.objectContaining({
          algorithm: 'RS256',
          issuer: expect.any(String),
          audience: expect.any(String)
        })
      );
      expect(result).toEqual(mockDecoded);
    });

    it('should verify with correct algorithm', () => {
      vi.mocked(jwt.verify).mockReturnValue({ userId: 1 } as any);
      
      verifyAccessToken('token');
      
      const callArgs = vi.mocked(jwt.verify).mock.calls[0];
      expect(callArgs[2]).toMatchObject({ algorithm: 'RS256' });
    });

    it('should verify issuer claim', () => {
      vi.mocked(jwt.verify).mockReturnValue({ userId: 1 } as any);
      
      verifyAccessToken('token');
      
      const callArgs = vi.mocked(jwt.verify).mock.calls[0];
      expect(callArgs[2]).toHaveProperty('issuer');
      expect(callArgs[2]?.issuer).toBeTruthy();
    });

    it('should verify audience claim', () => {
      vi.mocked(jwt.verify).mockReturnValue({ userId: 1 } as any);
      
      verifyAccessToken('token');
      
      const callArgs = vi.mocked(jwt.verify).mock.calls[0];
      expect(callArgs[2]).toHaveProperty('audience');
      expect(callArgs[2]?.audience).toBeTruthy();
    });

    it('should return decoded payload', () => {
      const expectedDecoded = { 
        userId: 456, 
        email: 'user@test.com',
        iat: 1234567890,
        exp: 1234568890
      };
      vi.mocked(jwt.verify).mockReturnValue(expectedDecoded as any);
      
      const result = verifyAccessToken('token');
      
      expect(result).toEqual(expectedDecoded);
    });

    it('should throw error for expired token', () => {
      const error = new Error('jwt expired');
      error.name = 'TokenExpiredError';
      vi.mocked(jwt.verify).mockImplementation(() => {
        throw error;
      });
      
      expect(() => verifyAccessToken('expired.token')).toThrow('jwt expired');
    });

    it('should throw error for invalid signature', () => {
      const error = new Error('invalid signature');
      error.name = 'JsonWebTokenError';
      vi.mocked(jwt.verify).mockImplementation(() => {
        throw error;
      });
      
      expect(() => verifyAccessToken('invalid.token')).toThrow('invalid signature');
    });

    it('should throw error for malformed token', () => {
      const error = new Error('jwt malformed');
      error.name = 'JsonWebTokenError';
      vi.mocked(jwt.verify).mockImplementation(() => {
        throw error;
      });
      
      expect(() => verifyAccessToken('malformed')).toThrow('jwt malformed');
    });
  });
});


import { generateRefreshToken, hashRefreshToken, compareRefreshToken } from '../../../src/auth/src/utils/jwt.ts';



describe('Refresh Token Utils', () => {
  describe('generateRefreshToken', () => {
    it('should generate a refresh token of expected length', () => {
      const token = generateRefreshToken();
      expect(typeof token).toBe('string');
      expect(token.length).toBe(128); 
    });

    it('should generate unique tokens on multiple calls', () => {
      const token1 = generateRefreshToken();
      const token2 = generateRefreshToken();
      expect(token1).not.toBe(token2);
    });
  });

  describe('hashRefreshToken', () => {
    it('should return a hashed version of the refresh token', () => {
      const refreshToken = 'sample-refresh-token';
      const hashedToken = hashRefreshToken(refreshToken);
      expect(typeof hashedToken).toBe('string');
      expect(hashedToken).not.toBe(refreshToken);
      expect(hashedToken.length).toBe(64); 
    });
  });

  describe('compareRefreshToken', () => {
    it('should return true for matching refresh token and hash', () => {
      const refreshToken = 'another-sample-token';
      const hashedToken = hashRefreshToken(refreshToken);
      const isMatch = compareRefreshToken(refreshToken, hashedToken);
      expect(isMatch).toBe(true);
    });

    it('should return false for non-matching refresh token and hash', () => {
      const refreshToken =  'sample-token-one';
      const differentToken = 'sample-token-two';
      const hashedToken = hashRefreshToken(refreshToken);
      const isMatch = compareRefreshToken(differentToken, hashedToken);
      expect(isMatch).toBe(false);
    });
  });
});

